{"ast":null,"code":"export default function slideTo(index, speed, runCallbacks, internal) {\n  if (index === void 0) {\n    index = 0;\n  }\n\n  if (speed === void 0) {\n    speed = this.params.speed;\n  }\n\n  if (runCallbacks === void 0) {\n    runCallbacks = true;\n  }\n\n  if (typeof index !== 'number' && typeof index !== 'string') {\n    throw new Error(\"The 'index' argument cannot have type other than 'number' or 'string'. [\" + typeof index + \"] given.\");\n  }\n\n  if (typeof index === 'string') {\n    /**\r\n     * The `index` argument converted from `string` to `number`.\r\n     * @type {number}\r\n     */\n    var indexAsNumber = parseInt(index, 10);\n    /**\r\n     * Determines whether the `index` argument is a valid `number`\r\n     * after being converted from the `string` type.\r\n     * @type {boolean}\r\n     */\n\n    var isValidNumber = isFinite(indexAsNumber);\n\n    if (!isValidNumber) {\n      throw new Error(\"The passed-in 'index' (string) couldn't be converted to 'number'. [\" + index + \"] given.\");\n    } // Knowing that the converted `index` is a valid number,\n    // we can update the original argument's value.\n\n\n    index = indexAsNumber;\n  }\n\n  var swiper = this;\n  var slideIndex = index;\n  if (slideIndex < 0) slideIndex = 0;\n  var params = swiper.params,\n      snapGrid = swiper.snapGrid,\n      slidesGrid = swiper.slidesGrid,\n      previousIndex = swiper.previousIndex,\n      activeIndex = swiper.activeIndex,\n      rtl = swiper.rtlTranslate,\n      wrapperEl = swiper.wrapperEl;\n\n  if (swiper.animating && params.preventInteractionOnTransition) {\n    return false;\n  }\n\n  var skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n  var snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n\n  if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {\n    swiper.emit('beforeSlideChangeStart');\n  }\n\n  var translate = -snapGrid[snapIndex]; // Update progress\n\n  swiper.updateProgress(translate); // Normalize slideIndex\n\n  if (params.normalizeSlideIndex) {\n    for (var i = 0; i < slidesGrid.length; i += 1) {\n      var normalizedTranslate = -Math.floor(translate * 100);\n      var normalizedGird = Math.floor(slidesGrid[i] * 100);\n      var normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\n\n      if (typeof slidesGrid[i + 1] !== 'undefined') {\n        if (normalizedTranslate >= normalizedGird && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGird) / 2) {\n          slideIndex = i;\n        } else if (normalizedTranslate >= normalizedGird && normalizedTranslate < normalizedGridNext) {\n          slideIndex = i + 1;\n        }\n      } else if (normalizedTranslate >= normalizedGird) {\n        slideIndex = i;\n      }\n    }\n  } // Directions locks\n\n\n  if (swiper.initialized && slideIndex !== activeIndex) {\n    if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {\n      return false;\n    }\n\n    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\n      if ((activeIndex || 0) !== slideIndex) return false;\n    }\n  }\n\n  var direction;\n  if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset'; // Update Index\n\n  if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {\n    swiper.updateActiveIndex(slideIndex); // Update Height\n\n    if (params.autoHeight) {\n      swiper.updateAutoHeight();\n    }\n\n    swiper.updateSlidesClasses();\n\n    if (params.effect !== 'slide') {\n      swiper.setTranslate(translate);\n    }\n\n    if (direction !== 'reset') {\n      swiper.transitionStart(runCallbacks, direction);\n      swiper.transitionEnd(runCallbacks, direction);\n    }\n\n    return false;\n  }\n\n  if (params.cssMode) {\n    var isH = swiper.isHorizontal();\n    var t = -translate;\n\n    if (rtl) {\n      t = wrapperEl.scrollWidth - wrapperEl.offsetWidth - t;\n    }\n\n    if (speed === 0) {\n      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n    } else {\n      // eslint-disable-next-line\n      if (wrapperEl.scrollTo) {\n        var _wrapperEl$scrollTo;\n\n        wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _wrapperEl$scrollTo[isH ? 'left' : 'top'] = t, _wrapperEl$scrollTo.behavior = 'smooth', _wrapperEl$scrollTo));\n      } else {\n        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n      }\n    }\n\n    return true;\n  }\n\n  if (speed === 0) {\n    swiper.setTransition(0);\n    swiper.setTranslate(translate);\n    swiper.updateActiveIndex(slideIndex);\n    swiper.updateSlidesClasses();\n    swiper.emit('beforeTransitionStart', speed, internal);\n    swiper.transitionStart(runCallbacks, direction);\n    swiper.transitionEnd(runCallbacks, direction);\n  } else {\n    swiper.setTransition(speed);\n    swiper.setTranslate(translate);\n    swiper.updateActiveIndex(slideIndex);\n    swiper.updateSlidesClasses();\n    swiper.emit('beforeTransitionStart', speed, internal);\n    swiper.transitionStart(runCallbacks, direction);\n\n    if (!swiper.animating) {\n      swiper.animating = true;\n\n      if (!swiper.onSlideToWrapperTransitionEnd) {\n        swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n          if (!swiper || swiper.destroyed) return;\n          if (e.target !== this) return;\n          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);\n          swiper.onSlideToWrapperTransitionEnd = null;\n          delete swiper.onSlideToWrapperTransitionEnd;\n          swiper.transitionEnd(runCallbacks, direction);\n        };\n      }\n\n      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);\n    }\n  }\n\n  return true;\n}","map":{"version":3,"sources":["C:/Users/charl/OneDrive/Desktop/firebase-hosting/portfolio/REACT/node_modules/swiper/esm/components/core/slide/slideTo.js"],"names":["slideTo","index","speed","runCallbacks","internal","params","Error","indexAsNumber","parseInt","isValidNumber","isFinite","swiper","slideIndex","snapGrid","slidesGrid","previousIndex","activeIndex","rtl","rtlTranslate","wrapperEl","animating","preventInteractionOnTransition","skip","Math","min","slidesPerGroupSkip","snapIndex","floor","slidesPerGroup","length","initialSlide","emit","translate","updateProgress","normalizeSlideIndex","i","normalizedTranslate","normalizedGird","normalizedGridNext","initialized","allowSlideNext","minTranslate","allowSlidePrev","maxTranslate","direction","updateActiveIndex","autoHeight","updateAutoHeight","updateSlidesClasses","effect","setTranslate","transitionStart","transitionEnd","cssMode","isH","isHorizontal","t","scrollWidth","offsetWidth","scrollTo","_wrapperEl$scrollTo","behavior","setTransition","onSlideToWrapperTransitionEnd","e","destroyed","target","$wrapperEl","removeEventListener","addEventListener"],"mappings":"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","sourcesContent":["export default function slideTo(index, speed, runCallbacks, internal) {\r\n  if (index === void 0) {\r\n    index = 0;\r\n  }\r\n\r\n  if (speed === void 0) {\r\n    speed = this.params.speed;\r\n  }\r\n\r\n  if (runCallbacks === void 0) {\r\n    runCallbacks = true;\r\n  }\r\n\r\n  if (typeof index !== 'number' && typeof index !== 'string') {\r\n    throw new Error(\"The 'index' argument cannot have type other than 'number' or 'string'. [\" + typeof index + \"] given.\");\r\n  }\r\n\r\n  if (typeof index === 'string') {\r\n    /**\r\n     * The `index` argument converted from `string` to `number`.\r\n     * @type {number}\r\n     */\r\n    var indexAsNumber = parseInt(index, 10);\r\n    /**\r\n     * Determines whether the `index` argument is a valid `number`\r\n     * after being converted from the `string` type.\r\n     * @type {boolean}\r\n     */\r\n\r\n    var isValidNumber = isFinite(indexAsNumber);\r\n\r\n    if (!isValidNumber) {\r\n      throw new Error(\"The passed-in 'index' (string) couldn't be converted to 'number'. [\" + index + \"] given.\");\r\n    } // Knowing that the converted `index` is a valid number,\r\n    // we can update the original argument's value.\r\n\r\n\r\n    index = indexAsNumber;\r\n  }\r\n\r\n  var swiper = this;\r\n  var slideIndex = index;\r\n  if (slideIndex < 0) slideIndex = 0;\r\n  var params = swiper.params,\r\n      snapGrid = swiper.snapGrid,\r\n      slidesGrid = swiper.slidesGrid,\r\n      previousIndex = swiper.previousIndex,\r\n      activeIndex = swiper.activeIndex,\r\n      rtl = swiper.rtlTranslate,\r\n      wrapperEl = swiper.wrapperEl;\r\n\r\n  if (swiper.animating && params.preventInteractionOnTransition) {\r\n    return false;\r\n  }\r\n\r\n  var skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\r\n  var snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\r\n  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\r\n\r\n  if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {\r\n    swiper.emit('beforeSlideChangeStart');\r\n  }\r\n\r\n  var translate = -snapGrid[snapIndex]; // Update progress\r\n\r\n  swiper.updateProgress(translate); // Normalize slideIndex\r\n\r\n  if (params.normalizeSlideIndex) {\r\n    for (var i = 0; i < slidesGrid.length; i += 1) {\r\n      var normalizedTranslate = -Math.floor(translate * 100);\r\n      var normalizedGird = Math.floor(slidesGrid[i] * 100);\r\n      var normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\r\n\r\n      if (typeof slidesGrid[i + 1] !== 'undefined') {\r\n        if (normalizedTranslate >= normalizedGird && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGird) / 2) {\r\n          slideIndex = i;\r\n        } else if (normalizedTranslate >= normalizedGird && normalizedTranslate < normalizedGridNext) {\r\n          slideIndex = i + 1;\r\n        }\r\n      } else if (normalizedTranslate >= normalizedGird) {\r\n        slideIndex = i;\r\n      }\r\n    }\r\n  } // Directions locks\r\n\r\n\r\n  if (swiper.initialized && slideIndex !== activeIndex) {\r\n    if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {\r\n      return false;\r\n    }\r\n\r\n    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\r\n      if ((activeIndex || 0) !== slideIndex) return false;\r\n    }\r\n  }\r\n\r\n  var direction;\r\n  if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset'; // Update Index\r\n\r\n  if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {\r\n    swiper.updateActiveIndex(slideIndex); // Update Height\r\n\r\n    if (params.autoHeight) {\r\n      swiper.updateAutoHeight();\r\n    }\r\n\r\n    swiper.updateSlidesClasses();\r\n\r\n    if (params.effect !== 'slide') {\r\n      swiper.setTranslate(translate);\r\n    }\r\n\r\n    if (direction !== 'reset') {\r\n      swiper.transitionStart(runCallbacks, direction);\r\n      swiper.transitionEnd(runCallbacks, direction);\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  if (params.cssMode) {\r\n    var isH = swiper.isHorizontal();\r\n    var t = -translate;\r\n\r\n    if (rtl) {\r\n      t = wrapperEl.scrollWidth - wrapperEl.offsetWidth - t;\r\n    }\r\n\r\n    if (speed === 0) {\r\n      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\r\n    } else {\r\n      // eslint-disable-next-line\r\n      if (wrapperEl.scrollTo) {\r\n        var _wrapperEl$scrollTo;\r\n\r\n        wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _wrapperEl$scrollTo[isH ? 'left' : 'top'] = t, _wrapperEl$scrollTo.behavior = 'smooth', _wrapperEl$scrollTo));\r\n      } else {\r\n        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  if (speed === 0) {\r\n    swiper.setTransition(0);\r\n    swiper.setTranslate(translate);\r\n    swiper.updateActiveIndex(slideIndex);\r\n    swiper.updateSlidesClasses();\r\n    swiper.emit('beforeTransitionStart', speed, internal);\r\n    swiper.transitionStart(runCallbacks, direction);\r\n    swiper.transitionEnd(runCallbacks, direction);\r\n  } else {\r\n    swiper.setTransition(speed);\r\n    swiper.setTranslate(translate);\r\n    swiper.updateActiveIndex(slideIndex);\r\n    swiper.updateSlidesClasses();\r\n    swiper.emit('beforeTransitionStart', speed, internal);\r\n    swiper.transitionStart(runCallbacks, direction);\r\n\r\n    if (!swiper.animating) {\r\n      swiper.animating = true;\r\n\r\n      if (!swiper.onSlideToWrapperTransitionEnd) {\r\n        swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\r\n          if (!swiper || swiper.destroyed) return;\r\n          if (e.target !== this) return;\r\n          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\r\n          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);\r\n          swiper.onSlideToWrapperTransitionEnd = null;\r\n          delete swiper.onSlideToWrapperTransitionEnd;\r\n          swiper.transitionEnd(runCallbacks, direction);\r\n        };\r\n      }\r\n\r\n      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\r\n      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);\r\n    }\r\n  }\r\n\r\n  return true;\r\n}"]},"metadata":{},"sourceType":"module"}